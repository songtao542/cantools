import re
import time
import traceback
from decimal import Decimal
import os
import os.path
import time

from .java_source import Message
from .java_source import Signal
from .java_source import _is_sender_or_receiver
from .java_source import _format_comment
from .java_source import _format_range
from .java_source import _get
from ...version import __version__
from .java_model_source import camel_case
from .java_model_source import to_camel_case
from ...version import __version__

SOURCE_FMT = '''\
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This file was generated by cantools version {version} {date}.
 */
#include "jni.h"
#include "log.h"
#include "{database_name}.h"

#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))

#define FIND_CLASS(var, className) \\
        var = env->FindClass(className); \\
        LOG_FATAL_IF(! (var), "Unable to find class " className);

#define GET_METHOD_ID(var, clazz, methodName, methodDescriptor) \\
        var = env->GetMethodID(clazz, methodName, methodDescriptor); \\
        LOG_FATAL_IF(! (var), "Unable to find method " methodName);

#define GET_STATIC_METHOD_ID(var, clazz, methodName, methodDescriptor) \\
        var = env->GetStaticMethodID(clazz, methodName, methodDescriptor); \\
        LOG_FATAL_IF(! (var), "Unable to find static method " methodName);

#define GET_FIELD_ID(var, clazz, fieldName, fieldDescriptor) \\
        var = env->GetFieldID(clazz, fieldName, fieldDescriptor); \\
        LOG_FATAL_IF(! (var), "Unable to find field " fieldName);

{native_class_info}

{model_class_infos}

{jni_functions} 

static const JNINativeMethod gNativeMethods[] = {{
{jni_native_methods}
}};
        
extern "C" jint JNI_OnLoad(JavaVM *vm, void * /* reserved */) {{
    JNIEnv *env = nullptr;
    jint result = -1;

    if (vm->GetEnv((void **) &env, JNI_VERSION_1_4) != JNI_OK) {{
        ALOGE("GetEnv failed!");
        return result;
    }}
    ALOG_ASSERT(env, "Could not retrieve the env!");

    ALOGE("JNI_OnLoad start");
    
{register_native_lines}

{register_lines}\
    ALOGE("JNI_OnLoad end");

    return JNI_VERSION_1_4;
}}
'''

JNI_METHOD = '''\
jint unpack{frame_model_class}(JNIEnv *env, jclass clazz, jbyteArray bytes, jint length, jobject resultHolder) {{
    struct {database_name}_{message_name}_t dst_p{{}};
    jbyte *dataPtr = env->GetByteArrayElements(bytes, nullptr);
    {unpack_method}(&dst_p, (const uint8_t *) dataPtr, (size_t) length);
    
{set_fields}
    return 0;
}}
'''

UNPACK_METHOD = '''\
{database_name}_{message_name}_unpack\
'''

SET_FIELD_ITEM = '''\
    env->SetIntField(resultHolder, g{frame_model_class}Info.{frame_model_field}, (jint) dst_p.{dst_field});
'''

JNI_NATIVE_METHOD = '''\
    {{"unpack{frame_model_class}", "([BIL{frame_model_class_sign};)I", (void *) unpack{frame_model_class}}},
'''

NATIVE_CLASS_INFO = '''\
static struct {{
    jclass clazz;
    jmethodID constructor;
}} g{class_name}Info;
'''

NATIVE_CLASS_REGISTER = '''\
    FIND_CLASS(g{class_name}Info.clazz, "{class_path}")
    g{class_name}Info.clazz = jclass(env->NewGlobalRef(g{class_name}Info.clazz));
    env->RegisterNatives(g{class_name}Info.clazz, gNativeMethods, NELEM(gNativeMethods));
'''

CLASS_REGISTER = '''\
    FIND_CLASS(g{class_name}Info.clazz, "{class_path}")
    g{class_name}Info.clazz = jclass(env->NewGlobalRef(g{class_name}Info.clazz));
    GET_METHOD_ID(g{class_name}Info.constructor, g{class_name}Info.clazz, "<init>", "()V")
{fields}
'''

CLASS_FIELD_REGISTER = '''\
    GET_FIELD_ID(g{class_name}Info.{field_name}, g{class_name}Info.clazz, "{field_name}", "I")
'''

FRAME_MODEL_CLASS_INFO = '''\
static struct {{
    jclass clazz;
    jmethodID constructor;
{field_ids}\
}} g{frame_model_class}Info;
'''

FIELD_ID = '''\
    jfieldID {field_id_name};
'''


def _generate_class_info_field_id(signal):
    field_name = to_camel_case(signal.snake_name)
    field = FIELD_ID.format(field_id_name=field_name)
    return field


def _generate_class_info_field_ids(message):
    fields = []
    for signal in message.signals:
        fields.append(_generate_class_info_field_id(signal))
    return ''.join(fields)


def _generate_class_infos(messages,
                          node_name):
    model_class_infos = []
    for message in messages:
        if _is_sender_or_receiver(message, node_name):
            class_name = camel_case(message.snake_name)
            field_ids = _generate_class_info_field_ids(message)
            model_class = FRAME_MODEL_CLASS_INFO.format(field_ids=field_ids,
                                                        frame_model_class=class_name)
            model_class_infos.append(model_class)
    return '\n'.join(model_class_infos)


def _generate_jni_function_set_field(signal, class_name):
    field_name = to_camel_case(signal.snake_name)
    field = SET_FIELD_ITEM.format(frame_model_class=class_name,
                                  frame_model_field=field_name,
                                  dst_field=signal.snake_name)
    return field


def _generate_jni_function_set_fields(message, class_name):
    set_fields = []
    for signal in message.signals:
        set_fields.append(_generate_jni_function_set_field(signal, class_name))
    return ''.join(set_fields)


def _generate_jni_functions(database_name,
                            messages,
                            node_name):
    jni_methods = []
    for message in messages:
        if _is_sender_or_receiver(message, node_name):
            class_name = camel_case(message.snake_name)
            set_fields = _generate_jni_function_set_fields(message, class_name)
            unpack_method = UNPACK_METHOD.format(database_name=database_name,
                                                 message_name=message.snake_name)
            model_class = JNI_METHOD.format(frame_model_class=class_name,
                                            database_name=database_name,
                                            message_name=message.snake_name,
                                            unpack_method=unpack_method,
                                            set_fields=set_fields)
            jni_methods.append(model_class)
    return '\n'.join(jni_methods)


def _generate_native_class_info(class_name):
    return NATIVE_CLASS_INFO.format(class_name=class_name)


def _generate_jni_native_methods(messages, package, node_name):
    class_path = package.replace(".", "/") + "/"
    jni_methods = []
    for message in messages:
        is_sender_or_receiver = _is_sender_or_receiver(message, node_name)
        if not is_sender_or_receiver:
            continue
        else:
            frame_model_class_sign = class_path + camel_case(message.snake_name)
            jni_method = JNI_NATIVE_METHOD.format(frame_model_class=camel_case(message.snake_name),
                                                  frame_model_class_sign=frame_model_class_sign)
            jni_methods.append(jni_method)
    # [:-2] 截掉最后两个字符
    return (''.join(jni_methods))[:-2]


def _generate_register_native_class(class_name, package):
    class_path = package.replace(".", "/") + "/" + class_name
    return NATIVE_CLASS_REGISTER.format(class_name=class_name,
                                        class_path=class_path)


def _generate_register_field(signal, class_name):
    field_name = to_camel_case(signal.snake_name)
    field = CLASS_FIELD_REGISTER.format(class_name=class_name,
                                        field_name=field_name)
    return field


def _generate_register_fields(message):
    fields = []
    for signal in message.signals:
        class_name = camel_case(message.snake_name)
        fields.append(_generate_register_field(signal, class_name))
    return ''.join(fields)


def _generate_register_lines(messages, package, node_name):
    class_path = package.replace(".", "/") + "/"
    jni_methods = []
    for message in messages:
        is_sender_or_receiver = _is_sender_or_receiver(message, node_name)
        if not is_sender_or_receiver:
            continue
        else:
            fields = _generate_register_fields(message)
            frame_model_class_sign = class_path + camel_case(message.snake_name)
            jni_method = CLASS_REGISTER.format(class_name=camel_case(message.snake_name),
                                               class_path=frame_model_class_sign,
                                               fields=fields)
            jni_methods.append(jni_method)
    return ''.join(jni_methods)


def generate_jni(output_directory,
                 database,
                 database_name,
                 package_name,
                 bit_fields=False,
                 node_name=None):
    try:
        date = time.ctime()
        filename = camel_case(database_name)
        messages = [Message(message) for message in database.messages]
        model_class_infos = _generate_class_infos(messages, node_name)
        jni_functions = _generate_jni_functions(database_name, messages, node_name)
        jni_native_methods = _generate_jni_native_methods(messages, package_name, node_name)
        register_native_lines = _generate_register_native_class(filename, package_name)
        register_lines = _generate_register_lines(messages, package_name, node_name)
        native_class_info = _generate_native_class_info(filename)
        source = SOURCE_FMT.format(version=__version__,
                                   date=date,
                                   database_name=database_name,
                                   model_class_infos=model_class_infos,
                                   jni_functions=jni_functions,
                                   jni_native_methods=jni_native_methods,
                                   register_native_lines=register_native_lines,
                                   register_lines=register_lines,
                                   native_class_info=native_class_info)
        filename_java = filename + '.cpp'
        os.makedirs(output_directory, exist_ok=True)
        path_java = os.path.join(output_directory, filename_java)
        with open(path_java, 'w') as fout:
            fout.write(source)
    except Exception as e:
        print(e.args)
        print(traceback.format_exc())
