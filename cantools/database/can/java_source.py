import re
import time
import traceback
from decimal import Decimal

from ...version import __version__

SOURCE_FMT = '''\
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This file was generated by cantools version {version} {date}.
 */

import java.util.Arrays; 
 
public class {file_name} {{
 
    public static final int EINVAL = 22;
 
    /* Frame ids. */
{frame_id_defines}

    /* Frame lengths in bytes. */
{frame_length_defines}

    /* Extended or standard frame types. */
{is_extended_frame_defines}

    /* Frame cycle times in milliseconds. */
{frame_cycle_time_defines}

    /* Signal choices. */
{choices_defines}

{variables}

{value_map}

{helpers}\
{definitions}\

    private static {file_name} s{file_name};

    public static {file_name} getInstance(){{
        if (s{file_name} == null) {{
            synchronized ({file_name}.class) {{
                if (s{file_name} == null) {{
                    s{file_name} = new {file_name}();
                }}
            }}
        }}
        return s{file_name};
    }}

}}
'''

VARIABLE_FMT = '''\
    /********** Signals in message {database_message_name}. {comment} All signal values are as on the CAN bus. **********/

{members}
'''

PACK_HELPER_LEFT_SHIFT_FMT = '''\
    private static final byte pack_left_shift(int value, int shift, int mask) {{
        return (byte) ((value << shift) & mask);
    }}
'''

PACK_HELPER_RIGHT_SHIFT_FMT = '''\
    private static final byte pack_right_shift(int value, int shift, int mask) {{
        return (byte) ((value >> shift) & mask);
    }}
'''

UNPACK_HELPER_LEFT_SHIFT_FMT = '''\
    private static final int unpack_left_shift(byte value, int shift, int mask) {{
        return (((int) value) & mask) << shift;
    }}
'''

UNPACK_HELPER_RIGHT_SHIFT_FMT = '''\
    private static final int unpack_right_shift(byte value, int shift, int mask) {{
        return (((int) value) & mask) >> shift;
    }}
'''

DEFINITION_NO_PARAMETER_PACK_FMT = '''\
    int {database_name}_{message_name}_pack(byte[] dst_p) {{
    if (dst_p.length < 8) {{
            return (-EINVAL);
        }}

        Arrays.fill(dst_p, (byte) 0);
        {pack_body}
        return ({message_length});
    }}

'''

DEFINITION_PACK_FMT = '''\
    public int {database_name}_{message_name}_pack(byte[] dst_p) {{
        return {database_name}_{message_name}_pack(
                dst_p,
               {src_parameter_name}
        );
    }}
    
    public int {database_name}_{message_name}_pack(
        byte[] dst_p,
        {src_parameter}) {{
        if (dst_p.length < 8) {{
            return (-EINVAL);
        }}
    
        Arrays.fill(dst_p, (byte) 0);
        {pack_body}
        return ({message_length});
    }}

'''

DEFINITION_UNPACK_FMT = '''\
    public int {database_name}_{message_name}_unpack(byte[] src_p) {{
        if (src_p.length < {message_length}) {{
            return (-EINVAL);
        }}
    {unpack_body}
        return (0);
    }}
'''

SIGNAL_DEFINITION_ENCODE_FMT = '''\
    {type_name} {database_name}_{message_name}_{signal_name}_encode({floating_point_type} value) {{
        return ({type_name}) ({encode});
    }}

'''

SIGNAL_DEFINITION_DECODE_FMT = '''\
    {floating_point_type} {database_name}_{message_name}_{signal_name}_decode({type_name} value) {{
        return ({decode});
    }}

'''

SIGNAL_DEFINITION_IS_IN_RANGE_FMT = '''\
    boolean {database_name}_{message_name}_{signal_name}_is_in_range({type_name} value) {{
        return ({check});
    }}
'''

EMPTY_DEFINITION_FMT = '''\
    int {database_name}_{message_name}_pack(
        byte[] dst_p,
        {src_parameter}) {{
        return (0);
    }}

    int {database_name}_{message_name}_unpack(byte[] src_p) {{
        return (0);
    }}
'''

SIGN_EXTENSION_FMT = '''
        if (({name} & (1{suffix} << {shift})) != 0{suffix}) {{
            {name} |= 0x{mask:x};
        }}

'''

SIGNAL_MEMBER_FMT = '''\
    /**
{comment}\
     * Range: {range}
     * Scale: {scale}
     * Offset: {offset}
     */
    public int {name}{length};\
'''


class Signal(object):

    def __init__(self, signal):
        self._signal = signal
        self.snake_name = camel_to_snake_case(self.name)

    def __getattr__(self, name):
        return getattr(self._signal, name)

    @property
    def unit(self):
        return _get(self._signal.unit, '-')

    @property
    def type_length(self):
        return 32

    @property
    def type_name(self):
        if self.is_float:
            if self.length == 32:
                type_name = 'float'
            else:
                type_name = 'double'
        else:
            if self.length == 64:
                type_name = 'long'
            else:
                type_name = 'int'
        return type_name

    @property
    def type_suffix(self):
        try:
            return {
                'long': 'L',
                'float': 'f'
            }[self.type_name]
        except KeyError:
            return ''

    @property
    def conversion_type_suffix(self):
        try:
            return {
                64: 'l'
            }[self.type_length]
        except KeyError:
            return ''

    @property
    def unique_choices(self):
        """Make duplicated choice names unique by first appending its value
        and then underscores until unique.

        """

        items = {
            value: camel_to_snake_case(str(name)).upper()
            for value, name in self.choices.items()
        }
        names = list(items.values())
        duplicated_names = [
            name
            for name in set(names)
            if names.count(name) > 1
        ]
        unique_choices = {
            value: name
            for value, name in items.items()
            if names.count(name) == 1
        }

        for value, name in items.items():
            if name in duplicated_names:
                name += _canonical('_{}'.format(value))

                while name in unique_choices.values():
                    name += '_'

                unique_choices[value] = name

        return unique_choices

    @property
    def minimum_type_value(self):
        return -2147483648

    @property
    def maximum_type_value(self):
        return 2147483647

    @property
    def minimum_value(self):
        if self.is_float:
            return None
        elif self.is_signed:
            return -(2 ** (self.length - 1))
        else:
            return 0

    @property
    def maximum_value(self):
        if self.is_float:
            return None
        elif self.is_signed:
            return (2 ** (self.length - 1)) - 1
        else:
            return (2 ** self.length) - 1

    def segments(self, invert_shift):
        index, pos = divmod(self.start, 8)
        left = self.length

        while left > 0:
            if self.byte_order == 'big_endian':
                if left >= (pos + 1):
                    length = (pos + 1)
                    pos = 7
                    shift = -(left - length)
                    mask = ((1 << length) - 1)
                else:
                    length = left
                    shift = (pos - length + 1)
                    mask = ((1 << length) - 1)
                    mask <<= (pos - length + 1)
            else:
                shift = (left - self.length) + pos

                if left >= (8 - pos):
                    length = (8 - pos)
                    mask = ((1 << length) - 1)
                    mask <<= pos
                    pos = 0
                else:
                    length = left
                    mask = ((1 << length) - 1)
                    mask <<= pos

            if invert_shift:
                if shift < 0:
                    shift = -shift
                    shift_direction = 'left'
                else:
                    shift_direction = 'right'
            else:
                if shift < 0:
                    shift = -shift
                    shift_direction = 'right'
                else:
                    shift_direction = 'left'

            yield index, shift, shift_direction, mask

            left -= length
            index += 1


class Message(object):

    def __init__(self, message):
        self._message = message
        self.snake_name = camel_to_snake_case(self.name)
        self.signals = [Signal(signal) for signal in message.signals]

    def __getattr__(self, name):
        return getattr(self._message, name)

    def get_signal_by_name(self, name):
        for signal in self.signals:
            if signal.name == name:
                return signal


def _canonical(value):
    """Replace anything but 'a-z', 'A-Z' and '0-9' with '_'.

    """

    return re.sub(r'[^a-zA-Z0-9]', '_', value)


def camel_to_snake_case(value):
    value = re.sub(r'(.)([A-Z][a-z]+)', r'\1_\2', value)
    value = re.sub(r'(_+)', '_', value)
    value = re.sub(r'([a-z0-9])([A-Z])', r'\1_\2', value).lower()
    value = _canonical(value)

    return value


def _strip_blank_lines(lines):
    try:
        while lines[0] == '':
            lines = lines[1:]

        while lines[-1] == '':
            lines = lines[:-1]
    except IndexError:
        pass

    return lines


def _get(value, default):
    if value is None:
        value = default

    return value


def _format_comment(comment):
    if comment:
        return '\n'.join([
            '     * ' + line.rstrip()
            for line in comment.splitlines()
        ]) + '\n     *\n'
    else:
        return ''


def _format_decimal(value, is_float=False, use_float=False):
    f_append = 'f' if use_float else ''
    if int(value) == value:
        value = int(value)

        if is_float:
            return f'{value}.0{f_append}'
        else:
            return str(value)
    else:
        return f'{value}{f_append}'


def _format_range(signal):
    minimum = signal.decimal.minimum
    maximum = signal.decimal.maximum
    scale = signal.decimal.scale
    offset = signal.decimal.offset

    if minimum is not None and maximum is not None:
        return '{}..{} ({}..{} {})'.format(
            _format_decimal((minimum - offset) / scale),
            _format_decimal((maximum - offset) / scale),
            minimum,
            maximum,
            signal.unit)
    elif minimum is not None:
        return '{}.. ({}.. {})'.format(
            _format_decimal((minimum - offset) / scale),
            minimum,
            signal.unit)
    elif maximum is not None:
        return '..{} (..{} {})'.format(
            _format_decimal((maximum - offset) / scale),
            maximum,
            signal.unit)
    else:
        return '-'


def _generate_signal(signal, bit_fields):
    comment = _format_comment(signal.comment)
    range_ = _format_range(signal)
    scale = _get(signal.scale, '-')
    offset = _get(signal.offset, '-')

    if signal.is_float or not bit_fields:
        length = ''
    else:
        length = ' : {}'.format(signal.length)

    member = SIGNAL_MEMBER_FMT.format(comment=comment,
                                      range=range_,
                                      scale=scale,
                                      offset=offset,
                                      type_name=signal.type_name,
                                      name=signal.snake_name,
                                      length=length)

    return member


def _append_4_space_at_front_of_lines(lines):
    new_lines = []
    for line in lines:
        new_lines.append("    {}".format(line))
    return new_lines


def _format_pack_code_mux(message,
                          mux,
                          body_lines_per_index,
                          helper_kinds):
    signal_name, multiplexed_signals = list(mux.items())[0]
    _format_pack_code_signal(message,
                             signal_name,
                             body_lines_per_index,
                             helper_kinds)
    multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
    signal_name = camel_to_snake_case(signal_name)

    lines = [
        '',
        'switch ({}) {{'.format(signal_name)
    ]

    for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:
        body_lines = _format_pack_code_level(message,
                                             multiplexed_signals,
                                             helper_kinds)
        lines.append('')
        lines.append('    case {}:'.format(multiplexer_id))

        if body_lines:
            lines.extend(_append_4_space_at_front_of_lines(body_lines[1:-1]))

        lines.append('        break;')

    lines.extend([
        '',
        '    default:',
        '        break;',
        '}'])

    return [('    ' + line).rstrip() for line in lines]


def _format_pack_code_signal(message,
                             signal_name,
                             body_lines,
                             helper_kinds):
    signal = message.get_signal_by_name(signal_name)
    for index, shift, shift_direction, mask in signal.segments(invert_shift=False):
        if signal.is_float or signal.is_signed:
            fmt = '    dst_p[{}] |= pack_{}_shift({}, {}, 0x{:02x});'
        else:
            fmt = '    dst_p[{}] |= pack_{}_shift({}, {}, 0x{:02x});'

        line = fmt.format(index,
                          shift_direction,
                          signal.snake_name,
                          shift,
                          mask)
        body_lines.append(line)
        helper_kinds.add(shift_direction)


def _format_pack_code_level(message,
                            signal_names,
                            helper_kinds):
    """Format one pack level in a signal tree.

    """

    body_lines = []
    muxes_lines = []

    for signal_name in signal_names:
        if isinstance(signal_name, dict):
            mux_lines = _format_pack_code_mux(message,
                                              signal_name,
                                              body_lines,
                                              helper_kinds)
            muxes_lines += mux_lines
        else:
            _format_pack_code_signal(message,
                                     signal_name,
                                     body_lines,
                                     helper_kinds)

    body_lines = body_lines + muxes_lines

    if body_lines:
        body_lines = [''] + body_lines + ['']

    return body_lines


def _format_pack_code(message, helper_kinds):
    body_lines = _format_pack_code_level(message,
                                         message.signal_tree,
                                         helper_kinds)

    return '\n    '.join(body_lines)


def _format_unpack_code_mux(message,
                            mux,
                            body_lines_per_index,
                            helper_kinds,
                            node_name):
    signal_name, multiplexed_signals = list(mux.items())[0]
    _format_unpack_code_signal(message,
                               signal_name,
                               body_lines_per_index,
                               helper_kinds)
    multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
    signal_name = camel_to_snake_case(signal_name)

    lines = [
        '    switch ({}) {{'.format(signal_name)
    ]

    for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:
        body_lines = _format_unpack_code_level(message,
                                               multiplexed_signals,
                                               helper_kinds,
                                               node_name)
        lines.append('')
        lines.append('        case {}:'.format(multiplexer_id))
        lines.extend(_append_4_space_at_front_of_lines(_strip_blank_lines(body_lines)))
        lines.append('            break;')

    lines.extend([
        '',
        '        default:',
        '            break;',
        '}'])

    return [('    ' + line).rstrip() for line in lines]


def _format_unpack_code_signal(message,
                               signal_name,
                               body_lines,
                               helper_kinds):
    signal = message.get_signal_by_name(signal_name)
    segments = signal.segments(invert_shift=True)

    for i, (index, shift, shift_direction, mask) in enumerate(segments):
        if signal.is_float or signal.is_signed:
            fmt = '        {} {} unpack_{}_shift(src_p[{}], {}, 0x{:02x});'
        else:
            fmt = '        {} {} unpack_{}_shift(src_p[{}], {}, 0x{:02x});'

        line = fmt.format(signal.snake_name,
                          '=' if i == 0 else '|=',
                          shift_direction,
                          index,
                          shift,
                          mask)
        body_lines.append(line)
        helper_kinds.add(shift_direction)

    if signal.is_signed:
        mask = ((1 << (signal.type_length - signal.length)) - 1)

        if mask != 0:
            mask <<= signal.length
            formatted = SIGN_EXTENSION_FMT.format(name=signal.snake_name,
                                                  shift=signal.length - 1,
                                                  mask=mask,
                                                  suffix=signal.conversion_type_suffix)
            body_lines.extend(formatted.splitlines())


def _format_unpack_code_level(message,
                              signal_names,
                              helper_kinds,
                              node_name):
    """Format one unpack level in a signal tree.

    """

    body_lines = []
    muxes_lines = []

    for signal_name in signal_names:
        if isinstance(signal_name, dict):
            mux_lines = _format_unpack_code_mux(message,
                                                signal_name,
                                                body_lines,
                                                helper_kinds,
                                                node_name)

            if muxes_lines:
                muxes_lines.append('')

            muxes_lines += mux_lines
        else:
            if not _is_receiver(message.get_signal_by_name(signal_name), node_name):
                continue

            _format_unpack_code_signal(message,
                                       signal_name,
                                       body_lines,
                                       helper_kinds)

    if body_lines:
        if body_lines[-1] != '':
            body_lines.append('')

    if muxes_lines:
        muxes_lines.append('')

    body_lines = body_lines + muxes_lines

    if body_lines:
        body_lines = [''] + body_lines

    return body_lines


def _format_unpack_code(message, helper_kinds, node_name):
    body_lines = _format_unpack_code_level(message,
                                           message.signal_tree,
                                           helper_kinds,
                                           node_name)

    return '\n'.join(body_lines)


def _generate_variable(message, bit_fields, variables):
    members = []
    for signal in message.signals:
        if signal.snake_name in variables:
            continue
        else:
            variables.append(signal.snake_name)
            members.append(_generate_signal(signal, bit_fields))

    if not members:
        members = []

    if message.comment is None:
        comment = ''
    else:
        comment = ' * {}\n *\n'.format(message.comment)

    return comment, members


def _format_choices(signal, signal_name):
    choices = []

    for value, name in sorted(signal.unique_choices.items()):
        if signal.is_signed:
            fmt = '{signal_name}_{name}_CHOICE = {value};'
        else:
            fmt = '{signal_name}_{name}_CHOICE = {value};'

        choices.append(fmt.format(signal_name=signal_name.upper(),
                                  name=str(name),
                                  value=value))

    return choices


def _generate_encode_decode(message, use_float):
    encode_decode = []

    floating_point_type = _get_floating_point_type(use_float)
    for signal in message.signals:
        scale = signal.decimal.scale
        offset = signal.decimal.offset
        formatted_scale = _format_decimal(scale, is_float=True, use_float=use_float)
        formatted_offset = _format_decimal(offset, is_float=True, use_float=use_float)

        if offset == 0 and scale == 1:
            encoding = 'value'
            decoding = '({}) value'.format(floating_point_type)
        elif offset != 0 and scale != 1:
            encoding = '(value - {}) / {}'.format(formatted_offset,
                                                  formatted_scale)
            decoding = '(({}) value * {}) + {}'.format(floating_point_type, formatted_scale,
                                                      formatted_offset)
        elif offset != 0:
            encoding = 'value - {}'.format(formatted_offset)
            decoding = '({}) value + {}'.format(floating_point_type, formatted_offset)
        else:
            encoding = 'value / {}'.format(formatted_scale)
            decoding = '({}) value * {}'.format(floating_point_type, formatted_scale)

        encode_decode.append((encoding, decoding))

    return encode_decode


def _generate_is_in_range(message):
    """Generate range checks for all signals in given message.

    """

    checks = []

    for signal in message.signals:
        scale = signal.decimal.scale
        offset = (signal.decimal.offset / scale)
        minimum = signal.decimal.minimum
        maximum = signal.decimal.maximum

        if minimum is not None:
            minimum = (minimum / scale - offset)

        if maximum is not None:
            maximum = (maximum / scale - offset)

        if minimum is None and signal.minimum_value is not None:
            if signal.minimum_value > signal.minimum_type_value:
                minimum = signal.minimum_value

        if maximum is None and signal.maximum_value is not None:
            if signal.maximum_value < signal.maximum_type_value:
                maximum = signal.maximum_value

        suffix = signal.type_suffix
        check = []

        if minimum is not None:
            if not signal.is_float:
                minimum = Decimal(int(minimum))

            minimum_type_value = signal.minimum_type_value

            if (minimum_type_value is None) or (minimum > minimum_type_value):
                minimum = _format_decimal(minimum, signal.is_float)
                check.append('(value >= {}{})'.format(minimum, suffix))

        if maximum is not None:
            if not signal.is_float:
                maximum = Decimal(int(maximum))

            maximum_type_value = signal.maximum_type_value

            if (maximum_type_value is None) or (maximum < maximum_type_value):
                maximum = _format_decimal(maximum, signal.is_float)
                check.append('(value <= {}{})'.format(maximum, suffix))

        if not check:
            check = ['true']
        elif len(check) == 1:
            check = [check[0][1:-1]]

        check = ' && '.join(check)

        checks.append(check)

    return checks


def _generate_frame_id_defines(database_name, messages, node_name):
    return '\n'.join([
        '    public static final int {}_{}_FRAME_ID = 0x{:02x};'.format(
            database_name.upper(),
            message.snake_name.upper(),
            message.frame_id)
        for message in messages if _is_sender_or_receiver(message, node_name)
    ])


def _generate_frame_length_defines(database_name, messages, node_name):
    result = '\n'.join([
        '    public static final int {}_{}_LENGTH = {};'.format(
            database_name.upper(),
            message.snake_name.upper(),
            message.length)
        for message in messages if _is_sender_or_receiver(message, node_name)
    ])

    return result


def _generate_frame_cycle_time_defines(database_name, messages, node_name):
    result = '\n'.join([
        '    public static final int {}_{}_CYCLE_TIME_MS = {};'.format(
            database_name.upper(),
            message.snake_name.upper(),
            message.cycle_time)
        for message in messages if message.cycle_time is not None and _is_sender_or_receiver(message, node_name)
    ])

    return result


def bool_to_string(bool_value):
    if bool_value:
        return "true"
    else:
        return "false"


def _generate_is_extended_frame_defines(database_name, messages, node_name):
    result = '\n'.join([
        '    public static final boolean {}_{}_IS_EXTENDED = {};'.format(
            database_name.upper(),
            message.snake_name.upper(),
            bool_to_string(message.is_extended_frame))
        for message in messages if _is_sender_or_receiver(message, node_name)
    ])

    return result


def _generate_choices_defines(database_name, messages, node_name):
    choices_defines = []

    for message in messages:
        is_sender = _is_sender(message, node_name)
        for signal in message.signals:
            if signal.choices is None:
                continue
            if not is_sender and not _is_receiver(signal, node_name):
                continue

            choices = _format_choices(signal, signal.snake_name)
            signal_choices_defines = '\n'.join([
                '    public static final int {}_{}_{}'.format(database_name.upper(),
                                                              message.snake_name.upper(),
                                                              choice)
                for choice in choices
            ])
            choices_defines.append(signal_choices_defines)

    return '\n\n'.join(choices_defines)


def _generate_variables(database_name, messages, bit_fields, node_name):
    structs = []
    variables = []
    for message in messages:
        if _is_sender_or_receiver(message, node_name):
            comment, members = _generate_variable(message, bit_fields, variables)
            structs.append(
                VARIABLE_FMT.format(comment=comment,
                                    database_message_name=message.name,
                                    message_name=message.snake_name,
                                    database_name=database_name,
                                    members='\n\n'.join(members)))

    return '\n'.join(structs)


def _is_sender(message, node_name):
    return node_name is None or node_name in message.senders


def _is_receiver(signal, node_name):
    return node_name is None or node_name in signal.receivers


def _is_sender_or_receiver(message, node_name):
    if _is_sender(message, node_name):
        return True
    return any(_is_receiver(signal, node_name) for signal in message.signals)


def _get_floating_point_type(use_float):
    return 'float' if use_float else 'double'


def _format_pack_code_parameter_mux(message, mux):
    parameter_lines = []
    parameter_name_lines = []
    signal_name, multiplexed_signals = list(mux.items())[0]
    multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
    name = camel_to_snake_case(signal_name)
    parameter_lines.append("int {},".format(name))
    parameter_name_lines.append(" {},".format(name))
    for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:
        mux_parameter_lines, mux_parameter_name_lines = _format_pack_code_parameter(message, multiplexed_signals, True)
        parameter_lines.append(mux_parameter_lines)
        parameter_name_lines.append(mux_parameter_name_lines)
    return parameter_lines, parameter_name_lines


def _format_pack_code_parameter_name(src_parameter):
    return src_parameter.replace("int", "")


def _format_pack_code_parameter(message, signal_names, is_mux):
    parameter_lines = []
    parameter_name_lines = []
    count = len(signal_names)
    index = 0
    for signal_name in signal_names:
        if isinstance(signal_name, dict):
            mux_parameter_lines, mux_parameter_name_lines = _format_pack_code_parameter_mux(message, signal_name)

            if mux_parameter_lines:
                mux_parameter_lines.append('')

            parameter_lines += mux_parameter_lines
            parameter_name_lines += mux_parameter_name_lines
            index += 1
        else:
            signal = message.get_signal_by_name(signal_name)
            if index == count - 1:
                if count == 1 and not is_mux:
                    fmt = 'int {}'
                    name_fmt = '        {}'
                elif not is_mux:
                    fmt = '\n        int {}'
                    name_fmt = '\n                {}'
                else:
                    fmt = '\n        int {},'
                    name_fmt = '\n                {},'
            elif index == 0 and not is_mux:
                fmt = 'int {},'
                name_fmt = ' {},'
            else:
                fmt = '\n        int {},'
                name_fmt = '\n                {},'
            line = fmt.format(signal.snake_name)
            parameter_lines.append(line)
            parameter_name_lines.append(name_fmt.format(signal.snake_name))
            index += 1
    return ''.join(parameter_lines), ''.join(parameter_name_lines)


def _format_unpack_code_clean_variables_mux(message, mux):
    clean_lines = []
    signal_name, multiplexed_signals = list(mux.items())[0]
    multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
    clean_lines.append("    this.{} = 0;".format(camel_to_snake_case(signal_name)))
    for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:
        mux_parameter_lines = _format_unpack_code_clean_variables(message, multiplexed_signals)
        clean_lines.append(mux_parameter_lines)
    return clean_lines


def _format_unpack_code_clean_variables(message, signal_names):
    clean_lines = []
    index = 0
    for signal_name in signal_names:
        if isinstance(signal_name, dict):
            mux_clean_lines = _format_unpack_code_clean_variables_mux(message, signal_name)

            if mux_clean_lines:
                mux_clean_lines.append('')

            clean_lines += mux_clean_lines
            index += 1
        else:
            signal = message.get_signal_by_name(signal_name)
            fmt = '\n        this.{} = 0;'
            line = fmt.format(signal.snake_name)
            clean_lines.append(line)
            index += 1
    return ''.join(clean_lines)


def _generate_definitions(database_name, messages, floating_point_numbers, use_float, node_name):
    try:
        definitions = []
        pack_helper_kinds = set()
        unpack_helper_kinds = set()

        for message in messages:
            signal_definitions = []
            is_sender = _is_sender(message, node_name)
            is_receiver = node_name is None

            for signal, (encode, decode), check in zip(message.signals,
                                                       _generate_encode_decode(message, use_float),
                                                       _generate_is_in_range(message)):
                if _is_receiver(signal, node_name):
                    is_receiver = True

                signal_definition = ''

                if floating_point_numbers:
                    if is_sender:
                        signal_definition += SIGNAL_DEFINITION_ENCODE_FMT.format(
                            database_name=database_name,
                            message_name=message.snake_name,
                            signal_name=signal.snake_name,
                            type_name=signal.type_name,
                            encode=encode,
                            floating_point_type=_get_floating_point_type(use_float))
                    if node_name is None or _is_receiver(signal, node_name):
                        signal_definition += SIGNAL_DEFINITION_DECODE_FMT.format(
                            database_name=database_name,
                            message_name=message.snake_name,
                            signal_name=signal.snake_name,
                            type_name=signal.type_name,
                            decode=decode,
                            floating_point_type=_get_floating_point_type(use_float))

                if is_sender or _is_receiver(signal, node_name):
                    signal_definition += SIGNAL_DEFINITION_IS_IN_RANGE_FMT.format(
                        database_name=database_name,
                        message_name=message.snake_name,
                        signal_name=signal.snake_name,
                        type_name=signal.type_name,
                        check=check)

                    signal_definitions.append(signal_definition)

            if message.length > 0:
                pack_body = _format_pack_code(message, pack_helper_kinds)
                unpack_body = _format_unpack_code(message, unpack_helper_kinds, node_name)
                definition = ""
                src_parameter, src_parameter_name = _format_pack_code_parameter(message, message.signal_tree, False)
                # clean_variables = _format_unpack_code_clean_variables(message, message.signal_tree)
                if is_sender:
                    if src_parameter == "" or src_parameter.isspace():
                        definition += DEFINITION_NO_PARAMETER_PACK_FMT.format(database_name=database_name,
                                                                              database_message_name=message.name,
                                                                              message_name=message.snake_name,
                                                                              message_length=message.length,
                                                                              pack_body=pack_body)
                    else:
                        definition += DEFINITION_PACK_FMT.format(database_name=database_name,
                                                                 database_message_name=message.name,
                                                                 message_name=message.snake_name,
                                                                 message_length=message.length,
                                                                 src_parameter_name=src_parameter_name,
                                                                 src_parameter=src_parameter,
                                                                 pack_body=pack_body)
                if is_receiver:
                    definition += DEFINITION_UNPACK_FMT.format(database_name=database_name,
                                                               database_message_name=message.name,
                                                               message_name=message.snake_name,
                                                               message_length=message.length,
                                                               # clean_variables=clean_variables,
                                                               unpack_body=unpack_body)
            else:
                definition = EMPTY_DEFINITION_FMT.format(database_name=database_name,
                                                         message_name=message.snake_name)

            if signal_definitions:
                definition += '\n' + '\n'.join(signal_definitions)

            if definition:
                definitions.append(definition)
        return '\n'.join(definitions), (pack_helper_kinds, unpack_helper_kinds)
    except Exception as e:
        print(e.args)
        print(traceback.format_exc())
        return ""


def _generate_helpers_kind(kinds, left_format, right_format):
    formats = {
        'left': left_format,
        'right': right_format
    }
    helpers = []

    for shift_direction in sorted(kinds):
        helper = formats[shift_direction].format()
        helpers.append(helper)

    return helpers


def _generate_helpers(kinds):
    pack_helpers = _generate_helpers_kind(kinds[0],
                                          PACK_HELPER_LEFT_SHIFT_FMT,
                                          PACK_HELPER_RIGHT_SHIFT_FMT)
    unpack_helpers = _generate_helpers_kind(kinds[1],
                                            UNPACK_HELPER_LEFT_SHIFT_FMT,
                                            UNPACK_HELPER_RIGHT_SHIFT_FMT)
    helpers = pack_helpers + unpack_helpers

    if helpers:
        helpers.append('')

    return '\n'.join(helpers)


def generate(database,
             database_name,
             file_name,
             floating_point_numbers=True,
             bit_fields=False,
             use_float=False,
             node_name=None):
    """Generate Java source code from given CAN database `database`.

    `database_name` is used as a prefix for all defines, data
    structures and functions.

    `file_name` is the file name of the Java source file.

    Set `floating_point_numbers` to ``True`` to allow floating point
    numbers in the generated code.

    Set `bit_fields` to ``True`` to generate bit fields in structs.
    
    Set `use_float` to ``True`` to prefer the `float` type instead
    of the `double` type for floating point numbers.

    `node_name` specifies the node for which message packers will be generated.
    For all other messages, unpackers will be generated. If `node_name` is not
    provided, both packers and unpackers will be generated. 

    This function returns a tuple of the C header and source files as
    strings.

    """

    date = time.ctime()
    messages = [Message(message) for message in database.messages]
    frame_id_defines = _generate_frame_id_defines(database_name, messages, node_name)
    frame_length_defines = _generate_frame_length_defines(database_name,
                                                          messages,
                                                          node_name)
    is_extended_frame_defines = _generate_is_extended_frame_defines(
        database_name,
        messages,
        node_name)
    frame_cycle_time_defines = _generate_frame_cycle_time_defines(
        database_name,
        messages,
        node_name)
    choices_defines = _generate_choices_defines(database_name, messages, node_name)
    variables = _generate_variables(database_name, messages, bit_fields, node_name)
    definitions, helper_kinds = _generate_definitions(database_name,
                                                      messages,
                                                      floating_point_numbers,
                                                      use_float,
                                                      node_name)
    helpers = _generate_helpers(helper_kinds)
    source = SOURCE_FMT.format(version=__version__,
                               date=date,
                               file_name=file_name,
                               frame_id_defines=frame_id_defines,
                               frame_length_defines=frame_length_defines,
                               is_extended_frame_defines=is_extended_frame_defines,
                               frame_cycle_time_defines=frame_cycle_time_defines,
                               choices_defines=choices_defines,
                               variables=variables,
                               value_map="",
                               helpers=helpers,
                               definitions=definitions)
    return source
