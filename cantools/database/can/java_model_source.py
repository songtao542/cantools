import os
import os.path
import time

from .java_source import Message
from .java_source import Signal
from .java_source import _is_sender_or_receiver
from .java_source import _format_comment
from .java_source import _format_range
from .java_source import _get
from ...version import __version__

MODEL_FMT = '''\
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This file was generated by cantools version {version} {date}.
 *
 * Signals in message {database_message_name}.
 *
{comment}\
 * All signal values are as on the CAN bus.
 */
package {package_name};

public class {message_name} {{
{members}
}}
'''

SIGNAL_MEMBER_FMT = '''\
    /**
{comment}\
     * Range: {range}
     * Scale: {scale}
     * Offset: {offset}
     */
    public {type_name} {name}{length};
    public static final int KEY_{name_upper} = {key};\
'''


def to_camel_case(snake_str):
    components = snake_str.split('_')
    return components[0] + ''.join(x.title() for x in components[1:])


def camel_case(snake_str):
    components = snake_str.split('_')
    return ''.join(x.title() for x in components[0:])


def _generate_signal(signal, index, bit_fields):
    comment = _format_comment(signal.comment)
    range_ = _format_range(signal)
    scale = _get(signal.scale, '-')
    offset = _get(signal.offset, '-')

    if signal.is_float or not bit_fields:
        length = ''
    else:
        length = ' : {}'.format(signal.length)
    member_name = to_camel_case(signal.snake_name)
    member = SIGNAL_MEMBER_FMT.format(comment=comment,
                                      range=range_,
                                      scale=scale,
                                      offset=offset,
                                      type_name=signal.type_name,
                                      name_upper=signal.snake_name.upper(),
                                      key=index,
                                      name=member_name,
                                      length=length)
    return member


def _generate_struct(message, index_base, bit_fields):
    members = []
    index = 0
    for signal in message.signals:
        members.append(_generate_signal(signal, (index_base + index), bit_fields))
        index += 1

    if not members:
        members = [
            '    /**\n'
            '     * Dummy signal in empty message.\n'
            '     */\n'
            '    public int dummy;'
        ]

    if message.comment is None:
        comment = ''
    else:
        comment = ' * {}\n *\n'.format(message.comment)

    return comment, members


def _generate_structs(output_directory,
                      database_name,
                      package_name,
                      messages,
                      bit_fields,
                      node_name):
    date = time.ctime()
    index_base = 0
    for message in messages:
        if _is_sender_or_receiver(message, node_name):
            comment, members = _generate_struct(message, index_base, bit_fields)
            class_name = camel_case(message.snake_name)
            model_class = MODEL_FMT.format(version=__version__,
                                           date=date,
                                           comment=comment,
                                           package_name=package_name,
                                           database_message_name=message.name,
                                           message_name=class_name,
                                           database_name=database_name,
                                           members='\n\n'.join(members))
            index_base += 1000
            filename_java = class_name + '.java'
            os.makedirs(output_directory, exist_ok=True)
            path_java = os.path.join(output_directory, filename_java)
            with open(path_java, 'w') as fout:
                fout.write(model_class)


def generate_model_class(output_directory,
                         database,
                         database_name,
                         package_name,
                         bit_fields=False,
                         node_name=None):
    messages = [Message(message) for message in database.messages]
    _generate_structs(output_directory, database_name, package_name, messages, bit_fields, node_name)
