import re
import time
import traceback
from decimal import Decimal
import os
import os.path
import time

from .java_source import Message
from .java_source import Signal
from .java_source import _is_sender_or_receiver
from .java_source import _is_receiver
from .java_source import _is_sender
from .java_model_source import camel_case
from .java_model_source import to_camel_case
from ...version import __version__

SOURCE_FMT = '''\
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This file was generated by cantools version {version} {date}.
 */
package {package_name};
 
{import_lines}
import java.util.function.BiConsumer;
 
public class {class_name} {{

{frame_ids}

{frame_models}

{native_methods}

    public static boolean parse(int frameId, byte[] data, int length) {{
{frame_unpacks}
        return false;
    }}
    
    private static {map} sValueMap = new {map}();
    private static Object sLock = new Object();
    
    static {{
        System.loadLibrary("{database_name}");
    }}

    private static boolean putIfNotEqual(int key, int value) {{
        int oldValue = sValueMap.get(key);
        if (oldValue != value) {{
            sValueMap.put(key, value);
            return true;
        }}
        return false;
    }}
    
{put_methods}

    public int get(int key) {{
        return sValueMap.get(key);
    }}

    public int get(int key, int valueIfKeyNotFound) {{
        return sValueMap.{get_func_name}(key, valueIfKeyNotFound);
    }}
    
    {for_each_method}
}}
'''

FRAME_MODEL_FMT = '''\
    private static final {message_name} s{message_name} = new {message_name}();
'''

NATIVE_METHOD_FMT = '''\
    private native static int unpack{message_name}(byte[] data, int length, {class_name} {param_name});
'''

FRAME_UNPACK_FMT = '''\
        if (frameId == FRAME_ID_{frame_id}) {{
            unpack{frame_model}(data, length, s{frame_model});
            return put(s{frame_model});
        }}
'''

PUT_METHOD_FMT = '''\
    public static boolean put({model_class} {param_model_class}) {{
        synchronized(sLock) {{
            boolean changed = false;
{put_items}\
            return changed;
        }}
    }}
'''

PUT_ITEM_FMT = '''\
            changed |= putIfNotEqual({model_class}.KEY_{key}, {param_model_class}.{model_class_field});
'''

FOR_EACH_METHOD = '''\
public void forEach(BiConsumer<Integer, Integer> action) {
        synchronized(sLock) {
            sValueMap.forEach(action);
        }
    }
'''

ANDROID_FOR_EACH_METHOD = '''\
public void forEach(BiConsumer<Integer, Integer> action) {
        synchronized(sLock) {
            for (int i = 0; i< sValueMap.size(); i++) {
                action.accept(sValueMap.keyAt(i), sValueMap.valueAt(i));
            }
        }
    }
'''

IMPORT = '''\
import java.util.HashMap;
'''

ANDROID_IMPORT = '''\
import android.util.SparseIntArray;
'''


def _generate_frame_ids(messages, node_name):
    return '\n'.join([
        '    public static final int FRAME_ID_{} = 0x{:02x};'.format(
            message.snake_name.upper(),
            message.frame_id)
        for message in messages if _is_sender_or_receiver(message, node_name)
    ])


def _generate_frame_models(messages, node_name):
    return '\n'.join([
        FRAME_MODEL_FMT.format(message_name=camel_case(message.snake_name))
        for message in messages if _is_sender_or_receiver(message, node_name)
    ])


def _generate_native_methods(messages, node_name):
    return '\n'.join([
        NATIVE_METHOD_FMT.format(message_name=camel_case(message.snake_name),
                                 class_name=camel_case(message.snake_name),
                                 param_name=to_camel_case(message.snake_name))
        for message in messages if _is_sender_or_receiver(message, node_name)
    ])


def _generate_frame_unpacks(messages, node_name):
    return '\n'.join([
        FRAME_UNPACK_FMT.format(frame_id=message.snake_name.upper(),
                                frame_model=camel_case(message.snake_name))
        for message in messages if _is_sender_or_receiver(message, node_name)
    ])


def _generate_put_items(message, is_sender, node_name):
    put_items = []
    for signal in message.signals:
        if signal.choices is None:
            continue
        if not is_sender and not _is_receiver(signal, node_name):
            continue

        put_item = PUT_ITEM_FMT.format(model_class=camel_case(message.snake_name),
                                       key=signal.snake_name.upper(),
                                       param_model_class=to_camel_case(message.snake_name),
                                       model_class_field=to_camel_case(signal.snake_name))
        put_items.append(put_item)
    return ''.join(put_items)


def _generate_put_methods(messages, node_name):
    put_methods = []
    for message in messages:
        is_sender_or_receiver = _is_sender_or_receiver(message, node_name)
        if not is_sender_or_receiver:
            continue
        else:
            is_sender = _is_sender(message, node_name)
            put_items = _generate_put_items(message, is_sender, node_name)
            put_method = PUT_METHOD_FMT.format(model_class=camel_case(message.snake_name),
                                               param_model_class=to_camel_case(message.snake_name),
                                               put_items=put_items)
            put_methods.append(put_method)

    return '\n'.join(put_methods)


def generate_native_class(output_directory,
                          database,
                          database_name,
                          package_name,
                          is_android,
                          node_name=None):
    try:
        date = time.ctime()
        filename = camel_case(database_name)
        messages = [Message(message) for message in database.messages]
        frame_ids = _generate_frame_ids(messages, node_name)
        frame_models = _generate_frame_models(messages, node_name)
        native_methods = _generate_native_methods(messages, node_name)
        frame_unpacks = _generate_frame_unpacks(messages, node_name)
        put_methods = _generate_put_methods(messages, node_name)
        if is_android:
            map_class = "SparseIntArray"
            get_func_name = "get"
            for_each_method = ANDROID_FOR_EACH_METHOD
            import_lines = ANDROID_IMPORT
        else:
            map_class = "HashMap<Integer, Integer>"
            get_func_name = "getOrDefault"
            for_each_method = FOR_EACH_METHOD
            import_lines = IMPORT
        source = SOURCE_FMT.format(version=__version__,
                                   date=date,
                                   package_name=package_name,
                                   import_lines=import_lines,
                                   class_name=filename,
                                   database_name=database_name,
                                   frame_ids=frame_ids,
                                   frame_models=frame_models,
                                   frame_unpacks=frame_unpacks,
                                   native_methods=native_methods,
                                   map=map_class,
                                   put_methods=put_methods,
                                   get_func_name=get_func_name,
                                   for_each_method=for_each_method)
        filename_java = filename + '.java'
        os.makedirs(output_directory, exist_ok=True)
        path_java = os.path.join(output_directory, filename_java)
        with open(path_java, 'w') as fout:
            fout.write(source)
    except Exception as e:
        print(e.args)
        print(traceback.format_exc())
